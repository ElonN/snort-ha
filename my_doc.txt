Stream handling

1. PluginManager::load_plugins loads stream_inspectors, which is defined in stream_inspectors.cc and one of them is "nin_stream_tcp", which is actually tcp_api (stream_tcp.cc::EOF)
2. FlowControl::process_tcp processes each TCP packet, gets its "flow" object from tcp_cache and calls FlowControl::process(flow, packet)
3. FlowControl::process checks flow's flow_state if needed, and if it's Flow::INSPECT, it calls flow->session->process(packet) which is TcpSession::process (tcp_session.cc)
4. tcp_cache: FlowControl::init_tcp allocates contingous memory for flow cache: tcp_mem = calloc(fc.max_sessions, sizeof(Flow)), then all Flow objects are puched into tcp_cache

TCP Stream Pattern Searching

1. noticed http requests/responses are validated (e.g checked that they start with "HTTP/") in validate() function
2. validate() is called by NHttpStartCutter::cut() (nhttp_cutter.cc) [which is common to all classes inheriting NHttpStartCutter - e.g NHttpRequestCutter, NHttpStatusCutter]
3. cut() is called by NHttpStreamSplitter::scan (nhttp_stream_splitter.cc) which is a common interface to all StreamSplitter (inhreting StreamSplitter)
4. StreamSplitter::scan() is called by paf_callback (paf.cc) <-- paf_check (paf.cc) <-- flush_pdu_ackd, flush_pdu_ips(tcp_reassembly.cc)
5. flush_pdu_ackd, flush_pdu_ips is responsible for iterating all tcp segments from seglist and scanning the reassembled buffer

TCP Tracker (defined in tcp_reassembly)
1. tracker has all segments that were received on a specific connection in seglist

tcp cache flow

2. 

Inspector assignment
1. on new tcp connection (NewTcpSession in tcp_session.cc) inoector is assiged according to flow->gadget
2. flow->gadget is assigned on binder::eval() --> binder::apply() --> stuff.apply_service() [binder.cc] accordinng to get_gadget(flow)
3. get_gadget(flow) uses s=get_protocol_name() and then InspectorManager::get_inspector(s)
4. 
1. snort_protocols.cc has get_protocol_name(uint16 port) which lookups id_map which has 

1. class StreamBase is an inspector (class StreamBase : public Inspector)
2. StreamBase has a member called flow_con (which is class FlowControl)
3. On StreamBase tinit, flow_con is initialized, and each type of stream is initialized (TCP, UDP, ICMP, FILE, PDU)
4. StreamBase tinit populates flow_con tcp (/udp/ucmp/...) calling flow_con.init_tcp() with TcpSession factory function from InspectorManager::get_session((uint16_t)PktType::TCP)


How does InspectorManager know TcpSession? through StreamTcp
1. StreamTcp inherits from Inspector, but it looks like nothing happens there. instead, the only interesting thing that happens is that StreamTcp refers TcpSession.
2. StreamTcp has a common inspect_api like all inspectors, and StreamTcp.ssn return a the function tcp_ssn(flow), that when called, initializes a TcpSession instance.
3. InspectorManager::get_session((uint16_t)PktType::TCP) finds StreamTcp using the enum PktType::TCP, and then returns StreamTcp.ssn 

packet p has p->flow
Session object is initialized with flow
flow has pointer to sesion object
