
=== ack


What: rule option to match on TCP ack numbers

Type: ips_option

Configuration: 

* string *ack.~range*: check if packet payload size is 'size | min<>max | <max | >min'

=== asn1


What: rule option for asn1 detection

Type: ips_option

Configuration: 

* implied *asn1.bitstring_overflow*: Detects invalid bitstring encodings that are known to be remotely exploitable.
* implied *asn1.double_overflow*: Detects a double ASCII encoding that is larger than a standard buffer.
* implied *asn1.print*: <>max | <max | >min
* int *asn1.oversize_length*: Compares ASN.1 type lengths with the supplied argument. { 0: }
* int *asn1.absolute_offset*: Absolute offset from the beginning of the packet. { 0: }
* int *asn1.relative_offset*: relative offset from the cursor.

=== base64_decode


What: rule option to decode base64 data - must be used with base64_data option

Type: ips_option

Configuration: 

* int *base64_decode.bytes*: Number of base64 encoded bytes to decode. { 1: }
* int *base64_decode.offset* = 0: Bytes past start of buffer to start decoding. { 0: }
* implied *base64_decode.relative*: Apply offset to cursor instead of start of buffer.

=== bufferlen


What: rule option to check length of current buffer

Type: ips_option

Configuration: 

* string *bufferlen.~range*: len | min<>max | <max | >min

=== byte_extract


What: rule option to convert data to an integer variable

Type: ips_option

Configuration: 

* int *byte_extract.~count*: number of bytes to pick up from the buffer { 1:10 }
* int *byte_extract.~offset*: number of bytes into the buffer to start processing { -65535:65535 }
* string *byte_extract.~name*: name of the variable that will be used in other rule options
* implied *byte_extract.relative*: offset from cursor instead of start of buffer
* int *byte_extract.multiplier* = 1: scale extracted value by given amount { 1:65535 }
* int *byte_extract.align* = 0: round the number of converted bytes up to the next 2- or 4-byte boundary { 0:4 }
* implied *byte_extract.big*: big endian
* implied *byte_extract.little*: little endian
* implied *byte_extract.dce*: dcerpc2 determines endianness
* implied *byte_extract.string*: convert from string
* implied *byte_extract.hex*: convert from hex string
* implied *byte_extract.oct*: convert from octal string
* implied *byte_extract.dec*: convert from decimal string

=== byte_jump


What: rule option to move the detection cursor

Type: ips_option

Configuration: 

* int *byte_jump.~count*: number of bytes to pick up from the buffer { 1:10 }
* string *byte_jump.~offset*: variable name or number of bytes into the buffer to start processing
* implied *byte_jump.relative*: offset from cursor instead of start of buffer
* implied *byte_jump.from_beginning*: jump from start of buffer instead of cursor
* int *byte_jump.multiplier* = 1: scale extracted value by given amount { 1:65535 }
* int *byte_jump.align* = 0: round the number of converted bytes up to the next 2- or 4-byte boundary { 0:4 }
* int *byte_jump.post_offset* = 0: also skip forward or backwards (positive of negative value) this number of bytes { -65535:65535 }
* implied *byte_jump.big*: big endian
* implied *byte_jump.little*: little endian
* implied *byte_jump.dce*: dcerpc2 determines endianness
* implied *byte_jump.string*: convert from string
* implied *byte_jump.hex*: convert from hex string
* implied *byte_jump.oct*: convert from octal string
* implied *byte_jump.dec*: convert from decimal string

=== byte_test


What: rule option to convert data to integer and compare

Type: ips_option

Configuration: 

* int *byte_test.~count*: number of bytes to pick up from the buffer { 1:10 }
* string *byte_test.~operator*: variable name or number of bytes into the buffer to start processing
* string *byte_test.~compare*: variable name or value to test the converted result against
* string *byte_test.~offset*: variable name or number of bytes into the payload to start processing
* implied *byte_test.relative*: offset from cursor instead of start of buffer
* implied *byte_test.big*: big endian
* implied *byte_test.little*: little endian
* implied *byte_test.dce*: dcerpc2 determines endianness
* implied *byte_test.string*: convert from string
* implied *byte_test.hex*: convert from hex string
* implied *byte_test.oct*: convert from octal string
* implied *byte_test.dec*: convert from decimal string

=== classtype


What: general rule option for rule classification

Type: ips_option

Configuration: 

* string *classtype.~*: classification for this rule

=== content


What: payload rule option for basic pattern matching

Type: ips_option

Configuration: 

* string *content.~data*: data to match
* implied *content.nocase*: case insensitive match
* implied *content.fast_pattern*: use this content in the fast pattern matcher instead of the content selected by default
* int *content.fast_pattern_offset* = 0: number of leading characters of this content the fast pattern matcher should exclude { 0: }
* int *content.fast_pattern_length*: maximum number of characters from this content the fast pattern matcher should use { 1: }
* string *content.offset*: var or number of bytes from start of buffer to start search
* string *content.depth*: var or maximum number of bytes to search from beginning of buffer
* string *content.distance*: var or number of bytes from cursor to start search
* string *content.within*: var or maximum number of bytes to search from cursor

=== cvs


What: payload rule option for detecting specific attacks

Type: ips_option

Configuration: 

* implied *cvs.invalid-entry*: looks for an invalid Entry string

=== detection_filter


What: rule option to require multiple hits before a rule generates an event

Type: ips_option

Configuration: 

* enum *detection_filter.track*: track hits by source or destination IP address { by_src | by_dst }
* int *detection_filter.count*: hits in interval before allowing the rule to fire { 1: }
* int *detection_filter.seconds*: length of interval to count hits { 1: }

=== dsize


What: rule option to test payload size

Type: ips_option

Configuration: 

* string *dsize.~range*: check if packet payload size is 'size | min<>max | <max | >min'

=== file_data


What: rule option to set detection cursor to file data

Type: ips_option

=== flags


What: rule option to test TCP control flags

Type: ips_option

Configuration: 

* string *flags.~test_flags*: these flags are tested
* string *flags.~mask_flags*: these flags are don't cares

=== flow


What: rule option to check session properties

Type: ips_option

Configuration: 

* implied *flow.to_client*: match on server responses
* implied *flow.to_server*: match on client requests
* implied *flow.from_client*: same as to_server
* implied *flow.from_server*: same as to_client
* implied *flow.established*: match only during data transfer phase
* implied *flow.not_established*: match only outside data transfer phase
* implied *flow.stateless*: match regardless of stream state
* implied *flow.no_stream*: match on raw packets only
* implied *flow.only_stream*: match on reassembled packets only
* implied *flow.no_frag*: match on raw packets only
* implied *flow.only_frag*: match on defragmented packets only

=== flowbits


What: rule option to set and test arbitrary boolean flags

Type: ips_option

Configuration: 

* string *flowbits.~command*: set|reset|isset|etc.
* string *flowbits.~arg1*: bits or group
* string *flowbits.~arg2*: group if arg1 is bits

=== fragbits


What: rule option to test IP frag flags

Type: ips_option

Configuration: 

* string *fragbits.~flags*: these flags are tested

=== fragoffset


What: rule option to test IP frag offset

Type: ips_option

Configuration: 

* string *fragoffset.~range*: check if packet payload size is 'size | min<>max | <max | >min'

=== gid


What: rule option specifying rule generator

Type: ips_option

Configuration: 

* int *gid.~*: generator id { 1: }

=== http_client_body


What: rule option to set the detection cursor to the request body

Type: ips_option

=== http_cookie


What: rule option to set the detection cursor to the HTTP cookie

Type: ips_option

=== http_header


What: rule option to set the detection cursor to the normalized header(s)

Type: ips_option

Configuration: 

* string *http_header.~name*: restrict to given header

=== http_method


What: rule option to set the detection cursor to the HTTP request method

Type: ips_option

=== http_raw_cookie


What: rule option to set the detection cursor to the unnormalized cookie

Type: ips_option

=== http_raw_header


What: rule option to set the detection cursor to the unnormalized headers

Type: ips_option

=== http_raw_uri


What: rule option to set the detection cursor to the unnormalized URI

Type: ips_option

=== http_stat_code


What: rule option to set the detection cursor to the HTTP status code

Type: ips_option

=== http_stat_msg


What: rule option to set the detection cursor to the HTTP status message

Type: ips_option

=== http_uri


What: rule option to set the detection cursor to the normalized URI buffer

Type: ips_option

=== icmp_id


What: rule option to check ICMP ID

Type: ips_option

Configuration: 

* string *icmp_id.~range*: check if icmp id is 'id | min<>max | <max | >min'

=== icmp_seq


What: rule option to check ICMP sequence number

Type: ips_option

Configuration: 

* string *icmp_seq.~range*: check if icmp sequence number is 'seq | min<>max | <max | >min'

=== icode


What: rule option to check ICMP code

Type: ips_option

Configuration: 

* string *icode.~range*: check if ICMP code is 'code | min<>max | <max | >min'

=== id


What: rule option to check the IP ID field

Type: ips_option

Configuration: 

* string *id.~range*: check if the IP ID is 'id | min<>max | <max | >min'

=== ip_proto


What: rule option to check the IP protocol number

Type: ips_option

Configuration: 

* string *ip_proto.~proto*: [!|>|<] name or number

=== ipopts


What: rule option to check for IP options

Type: ips_option

Configuration: 

* select *ipopts.~opt*: output format { rr|eol|nop|ts|sec|esec|lsrr|lsrre|ssrr|satid|any }

=== isdataat


What: rule option to check for the presence of payload data

Type: ips_option

Configuration: 

* string *isdataat.~length*: num | !num
* implied *isdataat.relative*: offset from cursor instead of start of buffer

=== itype


What: rule option to check ICMP type

Type: ips_option

Configuration: 

* string *itype.~range*: check if icmp type is 'type | min<>max | <max | >min'

=== md5


What: payload rule option for hash matching

Type: ips_option

Configuration: 

* string *md5.~hash*: data to match
* int *md5.length*: number of octets in plain text { 1:65535 }
* string *md5.offset*: var or number of bytes from start of buffer to start search
* implied *md5.relative* = false: offset from cursor instead of start of buffer

=== metadata


What: rule option for conveying arbitrary name, value data within the rule text

Type: ips_option

Configuration: 

* string *metadata.service*: service name
* string *metadata.**: additional parameters not used by snort

=== msg


What: rule option summarizing rule purpose output with events

Type: ips_option

Configuration: 

* string *msg.~*: message describing rule

=== pcre


What: rule option for matching payload data with regex

Type: ips_option

Configuration: 

* string *pcre.~regex*: Snort regular expression

=== pkt_data


What: rule option to set the detection cursor to the normalized packet data

Type: ips_option

=== priority


What: rule option for prioritizing events

Type: ips_option

Configuration: 

* int *priority.~*: relative severity level; 1 is highest priority { 1: }

=== raw_data


What: rule option to set the detection cursor to the raw packet data

Type: ips_option

=== reference


What: rule option to indicate relevant attack identification system

Type: ips_option

Configuration: 

* string *reference.~scheme*: reference scheme
* string *reference.~id*: reference id

=== rem


What: rule option to convey an arbitrary comment in the rule body

Type: ips_option

Configuration: 

* string *rem.~*: comment

=== replace


What: rule option to overwrite payload data; use with rewrite action

Type: ips_option

Configuration: 

* string *replace.~*: byte code to replace with

=== rev


What: rule option to indicate current revision of signature

Type: ips_option

Configuration: 

* int *rev.~*: revision { 1: }

=== rpc


What: rule option to check SUNRPC CALL parameters

Type: ips_option

Configuration: 

* string *rpc.~app*: application number
* string *rpc.~ver*: version number or * for any
* string *rpc.~proc*: procedure number or * for any

=== seq


What: rule option to check TCP sequence number

Type: ips_option

Configuration: 

* string *seq.~range*: check if packet payload size is 'size | min<>max | <max | >min'

=== session


What: rule option to check user data from TCP sessions

Type: ips_option

Configuration: 

* enum *session.~mode*: output format { printable|binary|all }

=== sha256


What: payload rule option for hash matching

Type: ips_option

Configuration: 

* string *sha256.~hash*: data to match
* int *sha256.length*: number of octets in plain text { 1:65535 }
* string *sha256.offset*: var or number of bytes from start of buffer to start search
* implied *sha256.relative* = false: offset from cursor instead of start of buffer

=== sha512


What: payload rule option for hash matching

Type: ips_option

Configuration: 

* string *sha512.~hash*: data to match
* int *sha512.length*: number of octets in plain text { 1:65535 }
* string *sha512.offset*: var or number of bytes from start of buffer to start search
* implied *sha512.relative* = false: offset from cursor instead of start of buffer

=== sid


What: rule option to indicate signature number

Type: ips_option

Configuration: 

* int *sid.~*: signature id { 1: }

=== sip_body


What: rule option to set the detection cursor to the request body

Type: ips_option

=== sip_header


What: rule option to set the detection cursor to the SIP header buffer

Type: ips_option

=== sip_method


What: detection option for sip stat code

Type: ips_option

Configuration: 

* string *sip_method.*method*: sip method

=== sip_stat_code


What: detection option for sip stat code

Type: ips_option

Configuration: 

* int *sip_stat_code.*code*: stat code { 1:999 }

=== so


What: rule option to call custom eval function

Type: ips_option

Configuration: 

* string *so.~func*: name of eval function

=== soid


What: rule option to specify a shared object rule ID

Type: ips_option

Configuration: 

* string *soid.~*: SO rule ID has <gid>|<sid> format, like 3|12345

=== ssl_state


What: detection option for ssl state

Type: ips_option

Configuration: 

* implied *ssl_state.client_hello*: check for client hello
* implied *ssl_state.server_hello*: check for server hello
* implied *ssl_state.client_keyx*: check for client keyx
* implied *ssl_state.server_keyx*: check for server keyx
* implied *ssl_state.unknown*: check for unknown record
* implied *ssl_state.!client_hello*: check for records that are not client hello
* implied *ssl_state.!server_hello*: check for records that are not server hello
* implied *ssl_state.!client_keyx*: check for records that are not client keyx
* implied *ssl_state.!server_keyx*: check for records that are not server keyx
* implied *ssl_state.!unknown*: check for records that are not unknown

=== ssl_version


What: detection option for ssl version

Type: ips_option

Configuration: 

* implied *ssl_version.sslv2*: check for sslv2
* implied *ssl_version.sslv3*: check for sslv3
* implied *ssl_version.tls1.0*: check for tls1.0
* implied *ssl_version.tls1.1*: check for tls1.1
* implied *ssl_version.tls1.2*: check for tls1.2
* implied *ssl_version.!sslv2*: check for records that are not sslv2
* implied *ssl_version.!sslv3*: check for records that are not sslv3
* implied *ssl_version.!tls1.0*: check for records that are not tls1.0
* implied *ssl_version.!tls1.1*: check for records that are not tls1.1
* implied *ssl_version.!tls1.2*: check for records that are not tls1.2

=== stream_reassemble


What: detection option for stream reassembly control

Type: ips_option

Configuration: 

* enum *stream_reassemble.action*: stop or start stream reassembly { disable|enable }
* enum *stream_reassemble.direction*: action applies to the given direction(s) { client|server|both }
* implied *stream_reassemble.noalert*: don't alert when rule matches
* implied *stream_reassemble.fastpath*: optionally whitelist the remainder of the session

=== stream_size


What: detection option for stream size checking

Type: ips_option

Configuration: 

* string *stream_size.~range*: size for comparison
* enum *stream_size.~direction*: compare applies to the given direction(s) { either|to_server|to_client|both }

=== tag


What: rule option to log additional packets

Type: ips_option

Configuration: 

* enum *tag.~*: log all packets in session or all packets to or from host { session|host_src|host_dst }
* int *tag.packets*: tag this many packets { 1: }
* int *tag.seconds*: tag for this many seconds { 1: }
* int *tag.bytes*: tag for this many bytes { 1: }

=== tos


What: rule option to check type of service field

Type: ips_option

Configuration: 

* string *tos.~range*: check if packet payload size is 'size | min<>max | <max | >min'

=== ttl


What: rule option to check time to live field

Type: ips_option

Configuration: 

* string *ttl.~range*: check if packet payload size is 'size | min<>max | <max | >min'

=== urg


What: detection for TCP urgent pointer

Type: ips_option

Configuration: 

* string *urg.~range*: check if urgent offset is min<>max | <max | >min

=== window


What: rule option to check TCP window field

Type: ips_option

Configuration: 

* string *window.~range*: check if packet payload size is 'size | min<>max | <max | >min'
